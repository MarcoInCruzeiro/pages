<html lang="pt-br" data-kantu="1"><head><meta name="ROBOTS" content="INDEX,FOLLOW"><meta name="keywords" content=""><meta name="description" content="">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guia do Jogo - Cruzeiro x AmÃ©rica</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&amp;display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rafaelcastrocouto/tusk-font@master/tusk.css">
  <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ESTILOS BASE DA LANDING PAGE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        @font-face {
            font-family: 'Tusk';
            src: url('https://cdn.jsdelivr.net/gh/rafaelcastrocouto/tusk-font@master/fonts/Tusk-Regular.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cor-primaria: #0a1a4f;
            --cor-secundaria: #142a7a;
            --cor-destaque: #ffc700;
            --cor-texto: #fff;
            --cor-texto-secundario: #b6c6f5;
            --espacamento-secao: 2rem;
            font-size: 16px;
        }

        body {
            font-family: 'Outfit', Arial, Helvetica, sans-serif;
            background: linear-gradient(135deg, var(--cor-primaria) 0%, var(--cor-secundaria) 100%);
            color: var(--cor-texto);
            min-height: 100vh;
            width: 100%;
            overflow-x: hidden;
            position: relative;
            transition: background 0.5s;
        }

        body::before {
            content: "";
            position: fixed;
            inset: 0;
            z-index: -1;
            background-image: url('https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/c814e061-5ce7-4be1-a7fa-014486876e07.png');
            background-repeat: repeat;
            opacity: 0.5;
            animation: bgmove 12s linear infinite;
            background-size: 1000px 1000px;
        }

        @keyframes bgmove {
            0% { background-position: 0 0; }
            100% { background-position: 200px 200px; }
        }

        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            padding: 0;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TOPO E CABEÃ‡ALHO
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .topo {
            position: relative;
            width: 100%;
            background: linear-gradient(180deg, var(--cor-primaria) 40%, rgba(20, 42, 122, 0.6) 100%);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border-radius: 0 0 32px 32px;
            overflow: hidden;
            margin: 0 auto;
        }

        .capaTopo {
            width: 100%;
            overflow: hidden;
            position: relative;
            z-index: 0;
        }

        .capaTopo::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(to top,
                rgba(10, 26, 79, 1) 0%,
                rgba(10, 26, 79, 0.6) 40%,
                rgba(10, 26, 79, 0.0) 100%
            );
            z-index: 1;
            pointer-events: none;
        }

        .img-jogadores {
            width: 100%;
            height: auto;
            min-height: 200px;
            max-height: 340px;
            object-fit: cover;
            display: block;
            filter: brightness(0.92) contrast(1.12) saturate(1.1);
        }

        .campeonato-img {
            max-width: 300px;
            height: auto;
            margin: 0 auto 1rem;
            display: block;
        }

        .tituloAbsoluto {
            text-align: center;
            margin-top: 0;
            padding-top: 24px;
            border-radius: 0 0 32px 32px;
        }

        .guia-titulo {
            max-width: 100%;
            width: auto;
            height: auto;
            max-height: 80px;
        }

        .rodada {
            display: flex;
            justify-content: center;
            margin-top: 1rem;
        }

        .rodada span {
            background: linear-gradient(90deg, #1e3fa3 60%, var(--cor-secundaria) 100%);
            color: var(--cor-texto);
            font-weight: 700;
            font-size: 1.15rem;
            padding: 6px 22px;
            border-radius: 12px;
            letter-spacing: 0.14em;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
        }

        .escudos {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            margin: 2rem 0 1rem 0;
            flex-wrap: wrap;
        }

        .escudo {
            width: 70px;
            height: 70px;
            object-fit: contain;
            transition: transform 0.2s;
        }

        .escudo:hover {
            transform: scale(1.08);
        }

        .versus {
            font-size: 3rem;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.95);
            opacity: 0.9;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .barra-divisoria {
            width: 2px;
            height: 70px;
            background-color: #ffffff;
            opacity: 0.5;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BOTÃ•ES E AÃ‡Ã•ES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .btn-ingressos {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin: 1.5rem 0;
            padding: 0 1rem;
        }

        .comprar-ingressos {
            background: linear-gradient(90deg, var(--cor-destaque) 60%, #ffe066 100%);
            color: var(--cor-primaria);
            font-weight: 900;
            font-size: 1.18rem;
            margin-bottom: 0;
            padding: 12px 40px;
            border-radius: 10px;
            text-decoration: none;
            box-shadow: 0 4px 16px rgba(255, 199, 0, 0.27);
            letter-spacing: 0.10em;
            border: none;
            transition: all 0.3s ease;
            cursor: pointer;
            width: 100%;
            min-width: 40%;
            text-align: center;
        }

        .comprar-ingressos:hover {
            background: linear-gradient(90deg, #ffe066 60%, var(--cor-destaque) 100%);
            box-shadow: 0 8px 32px rgba(255, 199, 0, 0.5);
            transform: scale(1.04);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CRONÃ”METRO
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .crono {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1.5rem 0;
            padding: 0 1rem;
        }

        .timer-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .timer-labels {
            color: var(--cor-texto-secundario);
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        #timer {
            background: linear-gradient(135deg, var(--cor-primaria) 0%, var(--cor-secundaria) 100%);
            color: white;
            font-family: 'Tusk', 'Outfit', monospace;
            font-size: 2.5rem;
            font-weight: 900;
            padding: 1rem 2rem;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-align: center;
            letter-spacing: 0.1em;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            animation: timerPulse 2s ease-in-out infinite alternate;
            min-width: 280px;
            backdrop-filter: blur(10px);
        }

        @keyframes timerPulse {
            0% {
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.1);
                border-color: rgba(255, 255, 255, 0.3);
            }
            100% {
                box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6), inset 0 2px 8px rgba(255, 255, 255, 0.2);
                border-color: rgba(255, 255, 255, 0.6);
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           INFO DO JOGO
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .info-jogo {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 900px;
            margin: 1rem auto;
            flex-wrap: wrap;
            border-radius: 18px;
            padding: 1rem;
            gap: 1rem;
        }

        .data-local,
        .horario-estadio {
            flex: 1;
            min-width: 250px;
            font-size: 1.18rem;
            font-weight: 600;
            color: var(--cor-texto);
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .ijuiz-estadio {
            width: 120px;
            max-width: 100%;
            margin: 5px auto;
            object-fit: contain;
            transition: transform 0.2s;
            display: block;
        }

        .ijuiz-estadio:hover {
            transform: scale(1.12) rotate(6deg);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SEÃ‡Ã•ES E ESTATÃSTICAS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .estatisticas, section {
            margin: 3.5rem auto 0;
            max-width: 900px;
            padding: 0 1.5rem;
        }

        .secao-titulo {
            background: linear-gradient(90deg, #1e3fa3 60%, var(--cor-secundaria) 100%);
            color: #ffffff;
            font-size: 1.5rem;
            font-weight: 900;
            text-align: center;
            padding: 14px 0;
            border-radius: 12px 12px 0 0;
            letter-spacing: 0.10em;
            margin-bottom: 0;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
        }

        .estatisticas-confronto {
            background: rgba(20, 42, 122, 0.85);
            border-radius: 0 0 18px 18px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
            margin-bottom: 2.5rem;
        }

        .stats-comparison {
            width: 100%;
            margin: 0 auto;
            padding: 1.5rem;
        }

        .teams-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2.5rem;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .team {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 30%;
        }

        .team-logo {
            width: 60px;
            height: 60px;
            object-fit: contain;
            margin: 0 auto 8px;
            display: block;
        }

        .team-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: #fff;
            text-align: center;
        }

        .jogos-container {
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
        }

        .jogos-titulo {
            font-size: 1rem;
            color: var(--cor-destaque);
            font-weight: 700;
            text-transform: uppercase;
        }

        .jogos-numero {
            font-size: 2.5rem;
            font-weight: 900;
            color: #fff;
        }

        .item-estatistica {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .estatistica-time-a,
        .estatistica-time-b {
            width: 40px;
            text-align: center;
            font-weight: bold;
            font-size: 22px;
            color: #ffffff;
        }

        .container-barra {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .titulo-estatistica {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .barras-estatisticas {
            display: flex;
            height: 20px;
            width: 100%;
            overflow: hidden;
            border-radius: 4px;
        }

        .barra {
            height: 100%;
        }

        .barra-time-a {
            background-color: #007bff;
        }

        .barra-time-b {
            background-color: #ffffff;
        }


        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HISTÃ“RICO E ESCALAÃ‡Ã•ES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .historico {
            max-width: 900px;
            margin: 0 auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }

        .historico-jogo {
            display: flex;
            flex-direction: column;
            background: rgba(20, 42, 122, 0.85);
            border-radius: 24px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
            margin: 2rem 0;
            overflow: hidden;
        }

        .foto-historica {
            width: 100%;
            padding: 1.5rem;
            background: var(--cor-primaria);
            border-radius: 0 0 24px 24px;
        }

        .foto-historica img {
            width: 100%;
            border-radius: 16px;
            object-fit: cover;
        }

        .detalhes-jogo {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            width: 100%;
        }

        .titulo-historico {
            text-align: center;
            width: 100%;
        }

        .titulo-historico .titulo {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }

        .titulo-historico .data {
            font-size: 1.7rem;
            color: var(--cor-texto-secundario);
            margin-bottom: 0.5rem;
        }

        .placar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            font-size: 2.8rem;
            font-weight: bold;
            color: var(--cor-destaque);
        }

        .divisoria {
            width: 2px;
            height: 32px;
            background-color: var(--cor-texto);
            opacity: 0.5;
        }

        .escudo-mini {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .escalacoes {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.8rem;
            max-width: 900px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        .time {
            flex: 1 1 180px;
            background: rgba(10, 26, 79, 0.85);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .time strong {
            font-size: 1.3rem;
            color: var(--cor-destaque);
            margin-bottom: 1rem;
            display: block;
        }

        .time ul {
            list-style: none;
            padding: 0;
            margin: 0;
            color: var(--cor-texto);
            font-size: 1rem;
            line-height: 1.5;
        }

        .tecnico {
            display: block;
            margin-top: 1rem;
            font-style: italic;
            font-weight: 600;
            color: var(--cor-texto-secundario);
            font-size: 0.95rem;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CURIOSIDADES E GALERIA
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .curiosidades {
            max-width: 900px;
            margin: 2.5rem auto;
            padding: 0 1.5rem;
        }

        .curiosidades p {
            background: rgba(20, 42, 122, 0.85);
            color: var(--cor-texto);
            font-size: 1.12rem;
            padding: 1.5rem;
            border-radius: 0 0 18px 18px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
            margin-bottom: 0;
            line-height: 1.6;
        }

        .curiosidades strong {
            color: var(--cor-destaque);
            font-weight: 900;
        }

        .galery-player {
            max-width: 900px;
            margin: 2.5rem auto;
            padding: 0 1.5rem;
        }

        .players-grid {
            display: flex;
            gap: 1.5rem;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            scroll-behavior: smooth;
            padding-bottom: 1rem;
        }

        .players-grid::-webkit-scrollbar {
            height: 6px;
        }

        .players-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .players-grid::-webkit-scrollbar-thumb {
            background: var(--cor-destaque);
            border-radius: 10px;
        }

        .port-player {
            flex: 0 0 140px;
            background: rgba(20, 42, 122, 0.85);
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            text-align: center;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            padding: 1rem;
            scroll-snap-align: center;
        }

        .position-player {
            font-size: 0.9rem;
            color: var(--cor-destaque);
            font-weight: 700;
            margin-bottom: 0.4rem;
        }

        .player-image {
            width: 100%;
            height: 160px;
            object-fit: cover;
            border-radius: 12px;
            margin-bottom: 0.8rem;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RODAPÃ‰
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .rodape {
            width: 100%;
            text-align: center;
            padding: 1.5rem 1rem;
            margin-top: 2.5rem;
            background: linear-gradient(90deg, var(--cor-secundaria) 60%, #1e3fa3 100%);
            box-shadow: 0 -2px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #footer-logo {
            max-width: 80px;
            height: auto;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MEDIA QUERIES RESPONSIVOS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        @media (min-width: 768px) {
            .btn-ingressos {
                flex-direction: row;
                gap: 1.5rem;
            }
            
            .comprar-ingressos {
                max-width: 250px;
            }
            
            .historico-jogo {
                flex-direction: row;
            }

            .foto-historica {
                max-width: 320px;
                border-radius: 0 24px 24px 0;
            }

            .escudo-mini {
                width: 55px;
                height: 55px;
            }
        }

        @media (max-width: 767px) {
            :root {
                font-size: 14px;
            }

            .campeonato-img {
                max-width: 240px;
            }

            .escudos {
                gap: 1rem;
            }

            .escudo {
                width: 50px;
                height: 50px;
            }

            .versus {
                font-size: 2rem;
            }

            #timer {
                font-size: 1.8rem;
                padding: 0.8rem 1.5rem;
                min-width: 240px;
            }

            .ijuiz-estadio {
                width: 100px;
            }
        }

        @media (min-width: 1024px) {
            .players-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 1.5rem;
                overflow-x: visible;
            }

            #timer {
                font-size: 3rem;
                min-width: 320px;
            }
        }
    </style>

</head>

<body>
    <section class="topo container">
        <header class="capaTopo">
          <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/aa258705-19cd-48a9-9357-4c5e48af558a.png" alt="Jogadores do Cruzeiro" class="img-jogadores" loading="eager">
        </header>

        <div class="tituloAbsoluto">
            <!-- Placeholder image for the campeonato title -->
            <img id="campeonato-logo" alt="Campeonato Mineiro" src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/d38b0bf8-b1f2-499b-bc82-a991321e6bac.png" class="campeonato-img" width="300" height="auto">
            
            <!-- Existing Guia do Jogo image -->
            <img class="guia-titulo" src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/f4e385b0-9102-4261-9ac5-88bc19d88ec2.png" alt="Guia do Jogo" width="640">
        </div>
        <div class="rodada">
            <span>7Âª RODADA<br>
            </span>
        </div>

        <div class="escudos">
            <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/1a619f2e-4cbe-4a07-a2d7-d32c26a5ea6d.png" alt="Cruzeiro" class="escudo" width="70" height="70">

            <span class="versus">
            <div class="barra-divisoria"></div>
            </span>

            <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/79f5dc99-e095-4f58-885a-c64bd96fe4af.png" alt="AmÃ©rica-MG" class="escudo" width="70" height="70">

        </div>
        <div class="btn-ingressos">
        <a href="https://socio.cruzeiro.com.br/jogos/150?utm_source=pages&utm_medium=guiadojogo_button&utm_campaign=cruXamg_080226&utm_id=cruXamg_080226&utm_term=ticketsales" class="comprar-ingressos">COMPRAR INGRESSOS</a>
        </div>

        <div class="crono">
            <div class="timer-container">
                <div class="timer-labels">DIAS, HORAS, MINUTOS e SEGUNDOS</div>
                <p id="timer"></p>
            </div>
        </div>


        <div class="info-jogo">

            <div class="data-local">
                <span>8 DE FEVEREIRO DE 2026</span>
                <span>BELO HORIZONTE (MG)</span>
            </div>

            <div class="horario-estadio">
                <p> <span>DOMINGO, 18H<br>
                </span> </p>
                <p><span>MINEIRÃƒO
                </span></p>
            </div>

            <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/4bff5b94-27cc-4061-826b-8453aa8c5d7d.png" alt="MineirÃ£o" class="ijuiz-estadio" width="180">
        </div>
    </section>

    <section class="estatisticas">
      <h2 class="secao-titulo">ğŸ“ˆ ESTATÃSTICAS DO CONFRONTO</h2>

        <div class="estatisticas-confronto">
            <div class="stats-comparison">
                <!-- Teams header -->
                <div class="teams-header">
                    <div class="team team-left">
                        <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/1a619f2e-4cbe-4a07-a2d7-d32c26a5ea6d.png" alt="Cruzeiro" class="team-logo">
                        <span class="team-name">CRUZEIRO</span>
                    </div>
                    <div class="jogos-container">
                        <span class="jogos-titulo">JOGOS</span>
                        <div class="jogos-numero">385&nbsp;</div>
                    </div>
                    <div class="team team-right">
                      <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/79f5dc99-e095-4f58-885a-c64bd96fe4af.png" alt="AmÃ©rica-MG" class="team-logo">
                        <span class="team-name">AMÃ‰RICA-MG&nbsp;</span>
                    </div>
                </div>


                <!-- VITÃ“RIAS -->
                <div class="item-estatistica">
                    <span class="estatistica-time-a">159&nbsp;</span>
                    <div class="container-barra">
                      <div class="titulo-estatistica">VITÃ“RIAS</div>
                        <!-- Removed the linha-central div -->
                        <div class="barras-estatisticas">
                          <div class="barra barra-time-a" style="flex: 159;"></div>
                          <div class="barra barra-time-b" style="flex: 110;"></div>
                        </div>
                    </div>
                    <span class="estatistica-time-b">110</span>
                </div>

                <!-- GOLS MARCADOS -->
                <div class="item-estatistica">
                    <span class="estatistica-time-a">672</span>
                    <div class="container-barra">
                      <div class="titulo-estatistica">GOLS MARCADOS</div>
                        <!-- Removed the linha-central div -->
                        <div class="barras-estatisticas">
                          <div class="barra barra-time-a" style="flex: 672;"></div>
                          <div class="barra barra-time-b" style="flex: 548;"></div>
                        </div>
                  </div>
                    <span class="estatistica-time-b">548</span>
              </div>




            </div>
        </div>
    </section>

    <section class="minigame">
            <h2 class="secao-titulo"> MINIGAME DO RAPOSINHO</h2>
            <section id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-layer">
            <div id="score-display">0</div>
            <div id="start-screen" class="modal" style="overflow-y: hidden;">
                <div class="modal-content">
                    <h1 class="title">Raposinho<br>Runner</h1>
                    <p class="subtitle">Desvie dos obstÃ¡culos e tente ir longe!</p>
                    <hr class="divider">
                    <div class="controls-info" style="font-size: 1rem; line-height: 1.6; color: #ddd;">
                        <div class="difficulty-container">
                            <button class="pixel-btn easy" data-difficulty="easy">FÃCIL</button>
                            <button class="pixel-btn normal" data-difficulty="normal">NORMAL</button>
                            <button class="pixel-btn hard active" data-difficulty="hard">DIFÃCIL</button>
                        </div>
                        
                        <p style="margin-top: 10px; font-size: 0.9em; color: #FFD700;">Dica: Pule duas vezes para ir mais alto!</p>
                        <p style="margin-top: 4px; font-size: 0.8em; color: #ffffff;">ApÃ³s 150 ponto pulo Triplo Ã© ativado!</p>
                    </div>
                    <button id="start-button" class="btn-main">JOGAR AGORA</button>
                </div>
            </div>
            <div id="game-over-screen" class="modal hidden">
                <div class="modal-content">
                    <h1 class="title danger">FIM DE JOGO</h1>
                    <p class="subtitle">NÃƒO FOI DESSA VEZ HEIN </p>
                    <hr class="divider">
                    <div style="font-size: 1.4rem; margin: 20px 0;">
                        PONTUAÃ‡ÃƒO FINAL<br>
                        <span id="final-score-val" style="color: #FFD700; font-weight: bold; font-size: 3rem;">0</span>
                    </div>
                    <button id="restart-button" class="btn-main">TENTAR DE NOVO</button>
                </div>
            </div>
            <div id="loading-screen">
                    <div class="loading-content">
                        <div class="loading-logo">
                            <h1>Bem-Vindo</h1>
                        </div>

                        <div class="loading-bar-container">
                            <div class="loading-bar">
                                <div id="loading-progress" class="loading-bar-fill"></div>
                            </div>

                            <div id="loading-text" class="loading-text">
                                Carregando... 0%
                            </div>

                            <div id="loading-details" class="loading-details">
                                Espere um pouco...
                            </div>
                        </div>
                    </div>
            </div>
        </div>
    <style>
            /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    MINIGAME - ESTILOS DO JOGO (VERSÃƒO CORRIGIDA)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Container do wrapper - fica DENTRO da section */
    #game-wrapper {
        position: relative;
        width: 100%;
        max-width: 900px;
        height: 600px; /* Altura fixa ou ajuste conforme necessÃ¡rio */
        margin: 0 auto;
        background: #0a1a4f;
        border-radius: 0px 0px 15px 15px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    /* Canvas do jogo */
    #gameCanvas {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: none;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
        border: none; /* Remove border duplicada */
    }

    /* UI Layer */
    #ui-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 10;
    }

    #ui-layer .modal, 
    #ui-layer #score-display, 
    #ui-layer #loading-screen {
        pointer-events: auto;
    }

    /* Score Display */
    #score-display {
        position: absolute;
        top: 15px;
        right: 15px;
        background: linear-gradient(to bottom, rgba(0, 61, 165, 0.9), rgba(20, 42, 122, 0.9));
        border: 2px solid white;
        color: white;
        padding: 8px 20px;
        font-weight: bold;
        font-size: 1.3rem;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        min-width: 80px;
        text-align: center;
    }

    /* Modais (Start e Game Over) */
    .modal {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 5, 36, 0.95);
        padding: 20px;
        z-index: 20;
        transition: opacity 0.3s;
    }

    .modal.hidden {
        display: none !important;
    }

    .modal-content {
        background: #00275A;
        border: 3px solid #4FC3F7;
        border-radius: 15px;
        padding: 25px;
        width: 100%;
        max-width: 450px;
        text-align: center;
        box-shadow: 0 0 50px rgba(0, 4, 29, 0.7);
        color: white;
        max-height: 90%;
        overflow-y: auto;
    }

    /* Tipografia dos modais */
    .title {
        color: #FFD700;
        font-size: 2rem;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .title.danger {
        color: #FF4444;
    }

    .subtitle {
        color: #4FC3F7;
        margin-bottom: 15px;
        font-size: 1rem;
    }

    .divider {
        border: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, #4FC3F7, transparent);
        margin: 15px auto;
    }

    .controls-info {
        font-size: 0.9rem;
        line-height: 1.5;
        color: #ddd;
        margin: 10px 0;
    }

    .controls-info strong {
        color: #FFD700;
    }

    /* BotÃµes */
    .btn-main {
        background: linear-gradient(to bottom, #4FC3F7, #2196F3);
        color: #001133;
        border: none;
        padding: 12px 30px;
        border-radius: 50px;
        font-weight: 800;
        font-size: 1.1rem;
        cursor: pointer;
        transition: transform 0.1s, filter 0.2s;
        margin-top: 15px;
        width: 100%;
        box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        text-transform: uppercase;
    }

    .btn-main:hover {
        filter: brightness(1.1);
        transform: scale(1.02);
    }

    .btn-main:active {
        transform: scale(0.98);
    }

    /* Container de dificuldade (se quiser reativar) */
    .difficulty-container {
        display: none; /* Oculto por padrÃ£o */
        gap: 10px;
        padding: 15px;
        margin: 10px 0;
    }

    .pixel-btn {
        flex: 1;
        padding: 12px;
        border: none;
        font-weight: 900;
        font-size: 1rem;
        color: white;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.1s;
        box-shadow: 0px 4px 0px rgba(0,0,0,0.4);
        border-radius: 4px;
    }

    .pixel-btn.easy { background-color: #4c89af; }
    .pixel-btn.normal { background-color: #2196F3; }
    .pixel-btn.hard { background-color: #0300b6; }

    .pixel-btn:hover {
        filter: brightness(1.1);
        transform: translateY(-2px);
    }

    .pixel-btn:active, 
    .pixel-btn.active {
        transform: translateY(4px); 
        box-shadow: 0px 0px 0px rgba(0,0,0,0.4); 
        border: 2px solid white; 
    }

    /* Loading Screen (confined to the game wrapper) */
    #loading-screen {
        position: absolute; /* confined inside #ui-layer */
        inset: 0;
        width: 100%;
        height: 100%;
        background: 
            radial-gradient(circle at center, #1a2a6f 0%, #050a20 100%),
            linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
            linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
        background-size: 100% 100%, 40px 40px, 40px 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 999; /* within wrapper */
        font-family: 'Orbitron', sans-serif;
        transition: opacity 0.5s ease-out, visibility 0.5s;
        border-radius: 12px;
        overflow: hidden;
    }

    #loading-screen.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
    }

    .loading-content {
        text-align: center;
        max-width: 500px;
        width: 90%;
        padding: 30px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 20px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(79, 195, 247, 0.1);
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
    }

    .loading-logo h1 {
        color: #FFD700;
        text-wrap: nowrap;
        font-size: 2.5rem;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 6px;
        margin: 0 0 40px 0;
        text-shadow: 
            0 0 10px rgba(255, 215, 0, 0.8),
            0 0 20px rgba(255, 215, 0, 0.4),
            0 0 40px rgba(255, 100, 0, 0.2);
        animation: titlePulse 3s ease-in-out infinite alternate;
    }

    @keyframes titlePulse {
        0% { transform: scale(1); filter: brightness(1); }
        100% { transform: scale(1.02); filter: brightness(1.2); }
    }

    .loading-bar-container {
        margin-top: 20px;
        position: relative;
    }

    .loading-bar {
        width: 100%;
        height: 20px;
        background: rgba(10, 20, 40, 0.6);
        border: 2px solid #2196F3;
        border-radius: 10px;
        padding: 2px;
        overflow: hidden;
        box-shadow: 
            0 0 15px rgba(33, 150, 243, 0.3),
            inset 0 0 10px rgba(0, 0, 0, 0.8);
        position: relative;
    }

    .loading-bar-fill {
        height: 100%;
        border-radius: 8px;
        background: linear-gradient(90deg, #2196F3, #00E5FF);
        width: 0%;
        transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        box-shadow: 0 0 10px rgba(0, 229, 255, 0.7);
    }

    .loading-bar-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        width: 100%;
        background: linear-gradient(
            90deg, 
            transparent, 
            rgba(255, 255, 255, 0.4), 
            transparent
        );
        transform: translateX(-100%);
        animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }

    .loading-text {
        color: #00E5FF;
        font-size: 1.1rem;
        font-weight: 700;
        margin-top: 15px;
        text-shadow: 0 0 8px rgba(0, 229, 255, 0.5);
        letter-spacing: 1px;
        text-wrap: nowrap;
    }

    .loading-details {
        color: rgba(255, 255, 255, 0.5);
        font-family: 'Courier New', monospace;
        font-size: 0.8rem;
        margin-top: 8px;
        min-height: 18px;
        text-transform: uppercase;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    RESPONSIVIDADE DO JOGO
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    @media (max-width: 767px) {
        #game-wrapper {
            height: 600px; /* Altura menor no mobile */

        }
        
        .modal-content {
            max-width: 90%;
        }
        
        .title {
            font-size: 1.6rem;
        }
        
        #score-display {
            font-size: 1.1rem;
            padding: 6px 15px;
            top: 10px;
            right: 10px;
        }
        
        .loading-logo h1 {
            font-size: 2rem;
            letter-spacing: 4px;
        }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
        #game-wrapper {
            height: 450px;
        }
    }

    @media (min-width: 1024px) {
        #game-wrapper {
            height: 550px; /* Altura maior em telas grandes */
        }
    }


    </style>
<script>

'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CONFIG = {
    GRAVITY: 0.6,
    JUMP_FORCE: -14,
    FAST_FALL_MULTIPLIER: 1.8,
    BASE_SPEED: 7,
    SPEED_ACCELERATION: 0.002,
    MAX_SPEED_MULTIPLIER: 2.5,
    MIN_OBSTACLE_DISTANCE: 250,
    SPAWN_VARIANCE: 600,
    MIN_SPAWN_DISTANCE: 180,
    BASE_SPAWN_CHANCE: 0.05,
    CROUCH_HEIGHT_MULTIPLIER: 0.6,
    COLLISION_PADDING: 3.5,
    TRIPLE_JUMP_SCORE: 100,
    SCORE_DIVISOR: 10,
    GROUND_HEIGHT: 40,
    GRID_SPACING_H: 13.5,
    GRID_SPACING_V: 100,
    PARTICLE_COUNT: 30,
    OUTDOOR_SPAWN_INTERVAL: 10,
    DEBUG_MODE: false
};

const DIFFICULTIES = {
    hard: {
        name: 'DifÃ­cil',
        speedMultiplier: 1.5,
        spawnRate: 1.5,
        tripleJumpScore: 100
    }
};

let currentDifficulty = 'hard';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ASSETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ASSETS = {
    raposinho: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/518e7232-4122-424f-9e22-5287b830731b.png',
    jump: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/4e53f535-7b37-4c60-9244-701f1ef03fe9.png',
    crouch: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/4560dec0-9390-4201-a87b-5aebd3c19d50.png',
    fastfall: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/69554b25-45ae-45e5-a917-de864cba302d.png',
    fall: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/dbd0b929-d67b-42ec-9957-e723f4662042.png',
    juiz: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/28c8fe96-a2f2-4746-a913-5c97d17398d4.png',
    bola: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/42fb5dd1-157d-4abe-8e2a-153a74b69ca7.png',
    chute: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/f21f5038-1ce5-4852-a2ef-103ab7d7ccda.png',
    bgSequence: ['https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/e294021b-609f-48bc-aac9-3a4688503275.png'],
    outdoor: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/bc38933e-eec1-49ea-b35c-8b01d3f74036.png',
    ground: 'https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/7100900e-756e-47b4-b76c-4b24783e398a.png'
};

const powerUpsAssets = {
    // lavitan: {
    //     img: './img/powerUpLavitan.png', // COMENTADO
    //     effectDuration: 5000,
    //     player: './img/power-player-lavitan.png' // COMENTADO - IMAGEM NÃƒO DISPONÃVEL
    // }
};

// Carregar imagens
const Images = {};
Object.keys(ASSETS).forEach(key => {
    if (key === 'bgSequence') return;
    Images[key] = new Image();
    Images[key].src = ASSETS[key];
});

Images.bgSequence = [];
if (Array.isArray(ASSETS.bgSequence)) {
    ASSETS.bgSequence.forEach(src => {
        const img = new Image();
        img.src = src;
        Images.bgSequence.push(img);
    });
}

const PowerUpImages = {};
const PowerUpPlayerImages = {};
Object.keys(powerUpsAssets).forEach(key => {
    PowerUpImages[key] = new Image();
    PowerUpImages[key].src = powerUpsAssets[key].img;
    PowerUpPlayerImages[key] = new Image();
    PowerUpPlayerImages[key].src = powerUpsAssets[key].player;
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLASSES DO JOGO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GameState {
    constructor() {
        this.reset();
    }
    reset() {
        this.isRunning = false;
        this.isGameOver = false;
        this.score = 0;
        this.frameCount = 0;
        this.currentSpeed = CONFIG.BASE_SPEED * (Game.scale || 1);
        this.gridOffset = 0;
        this.lastOutdoorTime = 0;
        this.slowMotionActive = false;
        this.slowMotionEndFrame = 0;
        this.activePowerUpCimed = null;
        this.powerUpStartY = 0;
        this.powerUpStartFrame = 0;
        this.obstacleSpawnBlockedUntilFrame = 0;
    }
}

class BackgroundManager {
    constructor(canvas, images) {
        this.canvas = canvas;
        this.images = images && images.length ? images : [];
        this.segments = [];
        this.currentImageIndex = 0;
        this.OVERLAP = 5; // Pixels de sobreposiÃ§Ã£o para evitar gaps
        
        console.log('BackgroundManager: Inicializando com', this.images.length, 'imagens');
        
        if (this.images.length === 0) {
            console.error('BackgroundManager: Nenhuma imagem fornecida!');
        }
        
        this._initSegments();
    }

    _initSegments() {
        this.segments = [];
        
        if (!this.canvas || this.canvas.width === 0 || this.canvas.height === 0) {
            console.warn('BackgroundManager: Canvas nÃ£o estÃ¡ pronto ainda');
            this.segments = [
                { x: 0, width: 800, height: 600, img: null, y: 0 },
                { x: 800, width: 800, height: 600, img: null, y: 0 }
            ];
            return;
        }

        // Verificar imagens vÃ¡lidas
        let validImage = null;
        for (let img of this.images) {
            if (img && img.complete && img.naturalWidth > 0) {
                validImage = img;
                break;
            }
        }

        if (!validImage) {
            console.warn('BackgroundManager: Nenhuma imagem vÃ¡lida carregada');
            this.segments = [
                { x: 0, width: this.canvas.width, height: this.canvas.height, img: null, y: 0 },
                { x: this.canvas.width, width: this.canvas.width, height: this.canvas.height, img: null, y: 0 }
            ];
            return;
        }

        // Criar 3 segmentos para garantir cobertura (em vez de 2)
        const segment1 = this._createSegmentData(0);
        const segment2 = this._createSegmentData(segment1.width - this.OVERLAP);
        const segment3 = this._createSegmentData(segment2.x + segment2.width - this.OVERLAP);
        
        this.segments = [segment1, segment2, segment3];
        
        console.log('BackgroundManager: Segmentos criados:', this.segments.map(s => 
            `x=${Math.floor(s.x)}, w=${Math.floor(s.width)}`
        ));
    }

    _createSegmentData(startX) {
        const img = this._getNextImage();
        
        if (!img || !img.complete || img.naturalWidth === 0) {
            return {
                x: startX,
                y: 0,
                width: this.canvas.width,
                height: this.canvas.height,
                img: null
            };
        }

        // Calcular dimensÃµes garantindo cobertura total
        const imgRatio = img.naturalWidth / img.naturalHeight;
        const canvasRatio = this.canvas.width / this.canvas.height;

        let width, height, offsetY = 0;

        if (imgRatio > canvasRatio) {
            // Imagem mais larga: ajustar pela altura com margem extra
            height = this.canvas.height + 10; // Margem extra para evitar gaps
            width = height * imgRatio;
        } else {
            // Imagem mais alta: ajustar pela largura com margem extra
            width = this.canvas.width + 10;
            height = width / imgRatio;
            offsetY = Math.max(0, (this.canvas.height - height) / 2);
        }

        return {
            x: startX,
            y: offsetY,
            width: width,
            height: height,
            img: img
        };
    }

    _getNextImage() {
        if (this.images.length === 0) return null;
        
        const img = this.images[this.currentImageIndex];
        this.currentImageIndex = (this.currentImageIndex + 1) % this.images.length;
        
        return img;
    }

    update(speed) {
        if (!this.segments || this.segments.length === 0) {
            console.warn('BackgroundManager.update: Sem segmentos, reinicializando');
            this._initSegments();
            return;
        }

        // Parallax speed (30% da velocidade do jogo)
        const parallaxSpeed = speed * 0.3;

        // Mover todos os segmentos
        for (let segment of this.segments) {
            segment.x -= parallaxSpeed;
        }

        // Verificar se precisa reciclar (com buffer maior)
        const recycleThreshold = -this.segments[0].width - 50; // Buffer de 50px
        
        if (this.segments[0].x < recycleThreshold) {
            // Remove o primeiro
            this.segments.shift();
            
            // Pega o Ãºltimo segmento
            const lastSegment = this.segments[this.segments.length - 1];
            
            // Calcula posiÃ§Ã£o com overlap para evitar gaps
            const newX = lastSegment.x + lastSegment.width - this.OVERLAP;
            
            // Cria e adiciona novo segmento
            const newSegment = this._createSegmentData(newX);
            this.segments.push(newSegment);
            
            console.log('BackgroundManager: Segmento reciclado, x:', Math.floor(newX), 'segmentos totais:', this.segments.length);
        }

        // PROTEÃ‡ÃƒO: Garantir que sempre hÃ¡ pelo menos 2 segmentos visÃ­veis
        if (this.segments.length < 2) {
            console.warn('BackgroundManager: Menos de 2 segmentos, corrigindo');
            const lastSegment = this.segments[this.segments.length - 1];
            const newX = lastSegment ? (lastSegment.x + lastSegment.width - this.OVERLAP) : this.canvas.width;
            this.segments.push(this._createSegmentData(newX));
        }
    }

    draw(ctx, speed) {
        if (!ctx || !this.canvas) return;

        this.update(speed);

        // Desenhar gradiente de fundo (sempre primeiro)
        const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        gradient.addColorStop(0, '#0a1a4f');
        gradient.addColorStop(1, '#4a108a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (!this.segments || this.segments.length === 0) return;

        // Desenhar segmentos
        for (let i = 0; i < this.segments.length; i++) {
            const segment = this.segments[i];
            
            // VerificaÃ§Ã£o de segmento vÃ¡lido
            if (!segment || typeof segment.x !== 'number') continue;
            
            // Pular apenas se COMPLETAMENTE fora da tela (com margem)
            const margin = 100;
            if (segment.x + segment.width < -margin) continue;
            if (segment.x > this.canvas.width + margin) continue;

            // Desenhar imagem ou fallback
            if (segment.img && segment.img.complete && segment.img.naturalWidth > 0) {
                try {
                    ctx.drawImage(
                        segment.img,
                        Math.floor(segment.x),
                        Math.floor(segment.y),
                        Math.ceil(segment.width),
                        Math.ceil(segment.height)
                    );
                } catch (e) {
                    console.error('Erro ao desenhar background segmento', i, ':', e);
                    // Desenhar fallback em caso de erro
                    ctx.fillStyle = i % 2 === 0 ? 'rgba(20, 40, 100, 0.5)' : 'rgba(40, 20, 100, 0.5)';
                    ctx.fillRect(
                        Math.floor(segment.x),
                        Math.floor(segment.y),
                        Math.ceil(segment.width),
                        Math.ceil(segment.height)
                    );
                }
            } else {
                // Fallback visual quando imagem nÃ£o estÃ¡ disponÃ­vel
                ctx.fillStyle = i % 2 === 0 ? 'rgba(20, 40, 100, 0.3)' : 'rgba(40, 20, 100, 0.3)';
                ctx.fillRect(
                    Math.floor(segment.x),
                    Math.floor(segment.y),
                    Math.ceil(segment.width),
                    Math.ceil(segment.height)
                );
            }
        }
    }

    resize() {
        console.log('BackgroundManager.resize chamado');
        
        if (!this.canvas || this.canvas.width === 0 || this.canvas.height === 0) {
            console.warn('BackgroundManager.resize: Canvas nÃ£o estÃ¡ pronto');
            setTimeout(() => this.resize(), 100);
            return;
        }

        this._initSegments();
    }
}

class Player {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.w = 60;
        this.h = 60;
        this.originalH = 60;
        this.dy = 0;
        this.groundY = 0;
        this.jumpCount = 0;
        this.maxJumps = 2;
        this.isCrouching = false;
        this.isFastFalling = false;
        
        if (Game.canvas && Game.scale > 0) {
            this._updateDimensions();
        }
    }

    _updateDimensions() {
        const playerBaseSize = 60 * Game.scale;
        this.w = playerBaseSize;
        this.h = playerBaseSize;
        this.originalH = playerBaseSize;
        this.x = Game.canvas.width * 0.1;
        this.groundY = Game.canvas.height - Game.groundHeight - (5 * Game.scale);
        this.y = this.groundY - this.h;
    }

    get isGrounded() {
        return this.dy === 0;
    }

    get hitbox() {
        const pad = CONFIG.COLLISION_PADDING * Game.scale;
        return {
            x: this.x + pad,
            y: this.y + pad,
            width: Math.max(4, this.w - pad * 2),
            height: Math.max(4, this.h - pad * 2)
        };
    }

    getCurrentSprite() {
        if (gameState.activePowerUpCimed && PowerUpPlayerImages[gameState.activePowerUpCimed]?.complete) {
            return PowerUpPlayerImages[gameState.activePowerUpCimed];
        }
        if (this.isFastFalling && Images.fastfall?.complete) {
            return Images.fastfall;
        }
        if (this.dy < 0 && Images.jump?.complete) {
            return Images.jump;
        }
        if (this.dy > 0 && !this.isFastFalling && Images.fall?.complete) {
            return Images.fall;
        }
        if (this.isCrouching && Images.crouch?.complete) {
            return Images.crouch;
        }
        return Images.raposinho;
    }

    jump() {
        if (gameState.activePowerUpCimed) return;
        if (this.jumpCount < this.maxJumps) {
            this.jumpCount++;
            const force = this.jumpCount === 1 ? CONFIG.JUMP_FORCE : CONFIG.JUMP_FORCE * 0.85;
            this.dy = force * Game.scale;
            ParticleSystem.create(this.x + this.w / 2, this.y + this.h, 5, '#fff');
        }
    }

    startCrouch() {
        if (gameState.activePowerUpCimed) return;
        if (this.isGrounded) {
            this.isCrouching = true;
            this.isFastFalling = false;
        } else {
            this.isFastFalling = true;
            this.isCrouching = false;
            if (this.dy < 0) {
                this.dy = 0;
            }
            this.dy += CONFIG.GRAVITY * 6 * Game.scale;
            ParticleSystem.create(this.x + this.w / 2, this.y, 8, '#00ffff');
        }
    }

    stopCrouch() {
        this.isCrouching = false;
        this.isFastFalling = false;
    }

    update() {
        if (gameState.activePowerUpCimed) {
            const TARGET_Y = Game.canvas.height * 0.2;
            const DURATION = 900;
            
            const rawProgress = (gameState.frameCount - gameState.powerUpStartFrame) / DURATION;
            const progress = Math.min(rawProgress, 1);
            const ease = 1 - Math.pow(1 - progress, 3);

            this.y = gameState.powerUpStartY + (TARGET_Y - gameState.powerUpStartY) * ease;

            const sizeMultiplier = 3;
            const sprite = this.getCurrentSprite();
            
            if (sprite?.complete && sprite.naturalWidth > 0) {
                const ratio = sprite.naturalWidth / sprite.naturalHeight;
                const baseWidth = this.w;
                const drawWidth = baseWidth * sizeMultiplier;
                const drawHeight = drawWidth / ratio;
                const drawY = (this.y + this.h) - drawHeight;
                
                const drawX = this.x - (drawWidth - this.w) / 2;
                const centerX = drawX + (drawWidth / 2);
                const centerY = drawY + (drawHeight * 0.5);
                
                ParticleSystem.createSonicBoom(centerX, centerY, drawHeight);
            }

            this.dy = 0;
            this.jumpCount = 0;
            this.isCrouching = false;
            this.isFastFalling = false;

            return;
        }

        const scaledGravity = this.isFastFalling 
            ? CONFIG.GRAVITY * CONFIG.FAST_FALL_MULTIPLIER * Game.scale
            : CONFIG.GRAVITY * Game.scale;

        this.dy += scaledGravity;

        if (this.isFastFalling) {
            const maxFallSpeed = 25 * Game.scale;
            this.dy = Math.min(this.dy, maxFallSpeed);
        }

        this.y += this.dy;

        if (this.y + this.h > this.groundY) {
            this.y = this.groundY - this.h;
            this.dy = 0;
            this.jumpCount = 0;

            if (this.isFastFalling) {
                ParticleSystem.create(this.x + this.w / 2, this.y + this.h, 12, '#ffaa00');
            }
            this.isFastFalling = false;
        }

        if (this.isCrouching && this.isGrounded) {
            this.h = this.originalH * CONFIG.CROUCH_HEIGHT_MULTIPLIER;
        } else {
            this.h = this.originalH;
        }

        if (this.isGrounded) {
            this.y = this.groundY - this.h;
        }

        this.maxJumps = gameState.score >= DIFFICULTIES[currentDifficulty].tripleJumpScore ? 3 : 2;
    }

    draw(ctx) {
        if (this.w === 0 || this.h === 0) {
            this._updateDimensions();
            return;
        }

        const sprite = this.getCurrentSprite();
        const isPoweredUp = gameState.activePowerUpCimed !== null;
        const sizeMultiplier = isPoweredUp ? 3 : 1;

        ctx.save();
        
        if (sprite && sprite.complete && sprite.naturalWidth > 0) {
            const ratio = sprite.naturalWidth / sprite.naturalHeight;
            const baseWidth = this.w * (this.isCrouching ? 1.2 : 1);
            const drawWidth = baseWidth * sizeMultiplier;
            const drawHeight = drawWidth / ratio;
            const drawY = (this.y + this.h) - drawHeight;

            let drawX = this.x;
            if (isPoweredUp) {
                drawX = this.x - (drawWidth - this.w) / 2;
            }

            ctx.drawImage(sprite, drawX, drawY, drawWidth, drawHeight);
            
        } else {
            ctx.fillStyle = '#FF6B00';
            ctx.fillRect(this.x, this.y, this.w * sizeMultiplier, this.h * sizeMultiplier);
            
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x, this.y, this.w * sizeMultiplier, this.h * sizeMultiplier);
            
            const eyeSize = 4 * Game.scale;
            const eyeY = this.y + (this.h * 0.3);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(this.x + (this.w * 0.3), eyeY, eyeSize, eyeSize);
            ctx.fillRect(this.x + (this.w * 0.6), eyeY, eyeSize, eyeSize);
        }
        
        ctx.restore();
    }
}

class Obstacle {
    constructor(type, x, y, size, config) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.width = size;
        this.height = size;
        this.initialY = y;
        this.isAirborne = config.isAirborne;
        this.speedFactor = config.speedFactor;
        this.rotation = config.rotation;
        this.wobbleAmplitude = config.wobbleAmplitude;
        this.wobbleSpeed = config.wobbleSpeed;
        this.wobblePhase = config.wobblePhase;
        this.hitBox = null;
        this.radius = null;
        this.cx = null;
        this.cy = null;
    }

    update(speed) {
        this.x -= speed;
    }

    isOffScreen() {
        return this.x + this.width < -100;
    }

    draw(ctx) {
        const x = this.x;
        const y = this.y;
        const w = this.width;
        const h = this.height;

        this.hitBox = null;
        this.radius = null;
        this.cx = null;
        this.cy = null;

        ctx.shadowColor = 'rgba(0, 0, 0, 0.35)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 3;
        ctx.shadowOffsetY = 3;

        if (this.type === 'bola') {
            this._drawBola(ctx, x, y, w, h);
        } else if (this.type === 'juiz') {
            this._drawJuiz(ctx, x, y, w, h);
        } else if (this.type === 'chute') {
            this._drawChute(ctx, x, y, w, h);
        }

        ctx.shadowColor = 'transparent';
    }

    _drawBola(ctx, x, y, w, h) {
        const cx = x + w / 2;
        const cy = y + h / 4;

        if (Images.bola?.complete && Images.bola.naturalWidth) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(this.rotation || 0);

            const aspect = Images.bola.naturalWidth / Images.bola.naturalHeight;
            let drawW = w;
            let drawH = drawW / aspect;
            if (drawH > h) {
                drawH = h;
                drawW = drawH * aspect;
            }

            ctx.drawImage(Images.bola, -drawW / 3, -drawH / 2, drawW, drawH);
            ctx.restore();

            this.radius = Math.min(drawW, drawH) / 2 * 0.7;
        } else {
            const r = Math.min(w, h) * 0.4;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            this.radius = r;
        }

        this.cx = cx;
        this.cy = cy;
    }

    _drawJuiz(ctx, x, y, w, h) {
        if (Images.juiz?.complete && Images.juiz.naturalWidth) {
            const cx = x + w / 2;
            const cy = y + h / 2;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate((this.rotation || 0) * 0.15);

            const aspect = Images.juiz.naturalWidth / Images.juiz.naturalHeight;
            let drawW = w;
            let drawH = drawW / aspect;
            if (drawH > h) {
                drawH = h;
                drawW = drawH * aspect;
            }

            ctx.drawImage(Images.juiz, -drawW / 2, -drawH / 2, drawW, drawH);
            ctx.restore();

            this.hitBox = {
                x: x + (w - drawW) / 2 + drawW * 0.2,
                y: y + (h - drawH) / 2 + drawH * 0.2,
                width: drawW * 0.6,
                height: drawH * 0.6
            };
        } else {
            ctx.fillStyle = '#808080';
            ctx.fillRect(x, y, w, h);
            this.hitBox = { x, y, width: w, height: h };
        }
    }

    _drawChute(ctx, x, y, w, h) {
        const wave = this.isAirborne 
            ? Math.sin((gameState.frameCount * 0.08) + (this.wobblePhase || 0)) * (this.wobbleAmplitude || 6)
            : 0;

        if (Images.chute?.complete && Images.chute.naturalWidth) {
            const aspect = Images.chute.naturalWidth / Images.chute.naturalHeight;
            let drawW = w;
            let drawH = drawW / aspect;
            if (drawH > h) {
                drawH = h;
                drawW = drawH * aspect;
            }

            const drawX = x + (w - drawW) / 2;
            const drawY = y + (h - drawH) / 2 + wave;

            ctx.save();
            ctx.translate(drawX + drawW / 2, drawY + drawH / 1.8);
            ctx.rotate((this.rotation || 0) * 0.08 + Math.sin((gameState.frameCount * 0.02) + (this.wobblePhase || 0)) * 0.02);
            ctx.drawImage(Images.chute, -drawW / 2, -drawH / 2, drawW, drawH);
            ctx.restore();

            this.hitBox = {
                x: drawX + drawW * 0.14,
                y: drawY + drawH * 0.2,
                width: drawW * 0.32,
                height: drawH * 0.75
            };
        } else {
            const clothW = w * 0.6;
            const clothH = h * 0.6;
            ctx.fillStyle = '#0066CC';
            ctx.fillRect(x, y + wave, clothW, clothH);
            this.hitBox = { x, y: y + wave, width: clothW, height: clothH };
        }
    }
}

class ObstacleManager {
    constructor() {
        this.obstacles = [];
    }

    spawn() {
        const types = ['bola', 'juiz', 'chute'];
        const type = types[Math.floor(Math.random() * types.length)];

        let sizeBase = (30 + Math.random() * 120) * Game.scale;
        if (type === 'chute') sizeBase *= (0.8 + Math.random() * 0.6);
        if (type === 'bola') sizeBase *= (0.9 + Math.random() * 0.4);
        const size = Math.max(24, sizeBase);

        const groundY = Game.canvas.height - Game.groundHeight;
        const canBeAir = type !== 'juiz';
        const isAirborne = canBeAir && Math.random() < 0.7;

        let y;
        if (isAirborne) {
            const jumpHeight = Math.abs(CONFIG.JUMP_FORCE);
            const maxDoubleJumpHeight = (jumpHeight * 1.5) + (jumpHeight * 0.85 * 1.5);
            const maxObstacleHeight = maxDoubleJumpHeight * (0.6 + Math.random() * 0.4);

            const flyHeightMultiplier = Math.random();
            const lift = flyHeightMultiplier > 0.5
                ? maxObstacleHeight * (0.4 + Math.random() * 0.6)
                : maxObstacleHeight * (0.1 + Math.random() * 0.7);

            y = groundY - size - lift;
            y = Math.max(20 * Game.scale, y);
        } else {
            y = groundY - size;
        }

        const x = Game.canvas.width + (100 + Math.random() * 200) * Game.scale;

        const obstacle = new Obstacle(type, x, y, size, {
            isAirborne,
            speedFactor: 0.6 + Math.random() * 0.8,
            rotation: (Math.random() - 0.5) * 0.8,
            wobbleAmplitude: isAirborne ? (3 + Math.random() * 20) * Game.scale : 0,
            wobbleSpeed: 0.01 + Math.random() * 0.1,
            wobblePhase: Math.random() * Math.PI * 2
        });

        this.obstacles.push(obstacle);
    }

    update(speed) {
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            this.obstacles[i].update(speed);

            if (this.obstacles[i].isOffScreen()) {
                this.obstacles.splice(i, 1);
            }
        }

        this._checkSpawn();
    }

    _checkSpawn() {
        if (gameState.activePowerUpCimed) return;
        if (gameState.obstacleSpawnBlockedUntilFrame && gameState.frameCount < gameState.obstacleSpawnBlockedUntilFrame) return;

        const lastOb = this.obstacles[this.obstacles.length - 1];
        const distanceToLast = lastOb ? (Game.canvas.width - lastOb.x) : Game.canvas.width;

        let baseDist = (CONFIG.MIN_OBSTACLE_DISTANCE * Game.scale) / (1 + gameState.score * 0.015);
        let randomVariance = Math.random() * (CONFIG.SPAWN_VARIANCE * Game.scale);
        let spawnThreshold = Math.max(baseDist + randomVariance, CONFIG.MIN_SPAWN_DISTANCE * Game.scale);

        if (distanceToLast > spawnThreshold) {
            const difficultyMod = DIFFICULTIES[currentDifficulty].spawnRate;
            const spawnChance = (CONFIG.BASE_SPAWN_CHANCE + (gameState.score * 0.0005)) * difficultyMod;
            if (Math.random() < spawnChance) {
                this.spawn();
            }
        }
    }

    draw(ctx) {
        this.obstacles.forEach(ob => ob.draw(ctx));
    }

    checkCollision(playerHitbox) {
        for (const ob of this.obstacles) {
            let collided = false;

            if (ob.type === 'bola' && ob.radius && ob.cx != null && ob.cy != null) {
                collided = CollisionSystem.rectCircle(playerHitbox, {
                    x: ob.cx - ob.radius,
                    y: ob.cy - ob.radius,
                    radius: ob.radius,
                    width: ob.radius * 2,
                    height: ob.radius * 2
                });
            } else {
                const hb = ob.hitBox || {
                    x: ob.x,
                    y: ob.y,
                    width: ob.width,
                    height: ob.height
                };
                collided = CollisionSystem.rectRect(playerHitbox, hb);
            }

            if (collided) return true;
        }
        return false;
    }

    clear() {
        this.obstacles = [];
    }
}

class OutdoorManager {
    constructor() {
        this.outdoors = [];
    }

    update(speed) {
        // Desabilitado temporariamente
    }

    draw(ctx) {
        // Desabilitado temporariamente
    }

    clear() {
        this.outdoors = [];
    }
}

class ParticleSystem {
    static instance = null;

    constructor() {
        this.particles = [];
        this.glowParticles = [];
        this._initGlowParticles();
    }

    _initGlowParticles() {
        if (!Game.canvas || Game.canvas.width === 0 || Game.canvas.height === 0) {
            setTimeout(() => this._initGlowParticles(), 100);
            return;
        }

        for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
            this.glowParticles.push({
                x: Math.random() * Game.canvas.width,
                y: Game.canvas.height - (Math.random() * (Game.groundHeight || 40)),
                size: Math.random() * 1.5,
                speedX: -2 - Math.random() * 3,
                alpha: Math.random()
            });
        }
    }

    static create(x, y, count, color) {
        if (!ParticleSystem.instance) return;

        for (let i = 0; i < count; i++) {
            ParticleSystem.instance.particles.push({
                x, y,
                dy: (Math.random() - 0.5) * 2,
                life: 20 + Math.random() * 10,
                color
            });
        }
    }

    static createSonicBoom(frontX, centerY, height) {
        if (!ParticleSystem.instance) return;

        const particleCount = 5;
        const spreadRange = height * 0.3;
        
        for (let i = 0; i < particleCount; i++) {
            const offsetY = (Math.random() - 0.5) * spreadRange;
            const velocityX = -(2 + Math.random() * 4);
            const velocityY = 1;
            
            ParticleSystem.instance.particles.push({
                x: frontX,
                y: centerY + offsetY,
                dx: velocityX,
                dy: velocityY,
                life: 40 + Math.random() * 30,
                maxLife: 70,
                color: '#FFD700',
                isSonic: true,
                alpha: 1,
                size: 3 + Math.random() * 4,
                glowIntensity: 20 + Math.random() * 15
            });
        }
    }

    update(speed) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            
            if (p.isSonic) {
                p.x += p.dx;
                p.y += p.dy;
                p.life--;
                p.alpha = p.life / p.maxLife;
            } else {
                p.x -= speed;
                p.y += p.dy;
                p.life--;
            }

            if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }

        const groundY = Game.canvas.height - Game.groundHeight;
        this.glowParticles.forEach(p => {
            p.x -= speed;
            p.alpha -= 0.01;

            if (p.x < -10 || p.alpha <= 0) {
                p.x = Game.canvas.width + 10;
                p.y = groundY + (Math.random() * Game.groundHeight);
                p.alpha = 0.5 + Math.random() * 0.5;
                p.size = 2 + Math.random() * 3;
            }
        });
    }

    draw(ctx) {
        this.particles.forEach(p => {
            if (p.isSonic) {
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.shadowBlur = p.glowIntensity;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * Game.scale);
                gradient.addColorStop(0, 'rgba(255, 255, 255, ' + p.alpha + ')');
                gradient.addColorStop(0.3, 'rgba(255, 215, 0, ' + p.alpha + ')');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * Game.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            } else {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 4 * Game.scale, 4 * Game.scale);
            }
        });

        const groundY = Game.canvas.height - Game.groundHeight;
        this.glowParticles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.alpha;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(p.x, p.y, p.size, p.size);
            ctx.restore();
        });
    }

    clear() {
        this.particles = [];
    }
}

class CollisionSystem {
    static rectRect(a, b) {
        return !(
            a.x > b.x + b.width ||
            a.x + a.width < b.x ||
            a.y > b.y + b.height ||
            a.y + a.height < b.y
        );
    }

    static rectCircle(rect, circle) {
        const cx = circle.x + (circle.radius ?? circle.width / 2);
        const cy = circle.y + (circle.radius ?? circle.height / 2);
        const r = circle.radius ?? Math.min(circle.width, circle.height) / 2;

        const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.height));

        const dx = cx - closestX;
        const dy = cy - closestY;

        return (dx * dx + dy * dy) <= (r * r);
    }
}

class Renderer {
    static instance = null; 

    constructor(canvas, ctx) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.backgroundManager = null;
    }

    clear() {
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        gradient.addColorStop(0, '#0a1a4f');
        gradient.addColorStop(1, '#4a108a');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    drawBackground() {
        // Se houver BackgroundManager usa a sequÃªncia
        if (this.backgroundManager) {
            // SÃ³ movimenta se o jogo estiver rodando
            const speed = gameState?.isRunning ? (gameState.currentSpeed || (CONFIG.BASE_SPEED * Game.scale)) : 0;
            this.backgroundManager.draw(this.ctx, speed);
            return;
        }

        // Fallback para bg Ãºnico antigo
        if (!Images.bg?.complete) return;

        this.ctx.save();
        const bgAspectRatio = Images.bg.naturalWidth / Images.bg.naturalHeight;
        const scaledBgWidth = this.canvas.height * bgAspectRatio;
        const bgSpeed = 1.5;
        const bgOffset = (gameState.frameCount * bgSpeed) % scaledBgWidth;

        for (let i = 0; i <= Math.ceil(this.canvas.width / scaledBgWidth) + 1; i++) {
            this.ctx.drawImage(
                Images.bg,
                (i * scaledBgWidth) - bgOffset,
                0,
                scaledBgWidth,
                this.canvas.height
            );
        }
        this.ctx.restore();
    }

    drawGround() {
        const ctx = this.ctx;
        const groundY = this.canvas.height - Game.groundHeight;

        if (Images.ground?.complete && Images.ground.naturalHeight > 1 && Images.ground.naturalWidth > 1) {
            ctx.save();
            
            // 1. FUNDAMENTAL PARA PIXEL ART: Desabilita a suavizaÃ§Ã£o (anti-aliasing)
            ctx.imageSmoothingEnabled = false;

            // 2. CÃ¡lculos de Escala (Mantendo a proporÃ§Ã£o da sua imagem 1920x400)
            const scale = Game.groundHeight / Images.ground.naturalHeight;
            const scaledWidth = Images.ground.naturalWidth * scale;

            // 3. MovimentaÃ§Ã£o (Ajuste a velocidade conforme o delta time se possÃ­vel)
            const groundSpeed = CONFIG.BASE_SPEED * Game.scale * 1; // Velocidade do chÃ£o (80% da velocidade base)
            // Usamos Math.floor para evitar que o pixel "dance" entre coordenadas decimais
            const groundOffset = Math.floor((gameState.frameCount * groundSpeed) % scaledWidth);

            // 4. Loop de renderizaÃ§Ã£o (Desenhamos apenas o necessÃ¡rio para preencher a tela)
            // Adicionamos +1 no loop para garantir que nÃ£o haja um buraco no final da tela
            for (let i = 0; i <= Math.ceil(this.canvas.width / scaledWidth) + 1; i++) {
                const xPos = Math.floor(i * scaledWidth - groundOffset);
                
                ctx.drawImage(
                    Images.ground,
                    xPos,
                    groundY,
                    scaledWidth,
                    Game.groundHeight
                );
            }
            
            ctx.restore();
        } else {
            // Fallback elegante enquanto a imagem nÃ£o carrega
            ctx.fillStyle = '#2d5016'; // Um verde escuro da sua paleta
            ctx.fillRect(0, groundY, this.canvas.width, Game.groundHeight);
        }

        // 5. Horizonte - Removi o neon pra combinar com a grama "realista"
        // Mas mantive uma linha de transiÃ§Ã£o para dar profundidade
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // Sombra sutil no topo da grama
        ctx.fillRect(0, groundY, this.canvas.width, 2 * Game.scale);
    }

    drawDebug(player, obstacles) {
        if (!CONFIG.DEBUG_MODE) return;
        if (!this.ctx) return;

        const ctx = this.ctx;
        ctx.save();
        // player hitbox
        try {
            if (player && player.hitbox) {
                ctx.strokeStyle = 'rgba(255,0,0,0.9)';
                ctx.lineWidth = 2;
                const hb = player.hitbox;
                ctx.strokeRect(hb.x, hb.y, hb.width, hb.height);
            }

            // obstacles
            if (Array.isArray(obstacles)) {
                obstacles.forEach(ob => {
                    if (!ob) return;
                    if (ob.radius && ob.cx != null && ob.cy != null) {
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(255,165,0,0.9)';
                        ctx.lineWidth = 2;
                        ctx.arc(ob.cx, ob.cy, ob.radius, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (ob.hitBox) {
                        ctx.strokeStyle = 'rgba(0,255,0,0.9)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(ob.hitBox.x, ob.hitBox.y, ob.hitBox.width, ob.hitBox.height);
                    } else {
                        ctx.strokeStyle = 'rgba(255,255,0,0.6)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(ob.x, ob.y, ob.width, ob.height);
                    }
                });
            }
        } catch (e) {
            console.warn('Renderer.drawDebug: erro ao desenhar debug', e);
        }

        ctx.restore();
    }
}

class PowerUpManager {
    constructor() {
        this.powerUps = [];
    }

    update(speed) {
        // Desabilitado temporariamente
    }

    draw(ctx) {
        // Desabilitado temporariamente
    }

    checkCollision(playerHitbox) {
        return null;
    }

    clear() {
        this.powerUps = [];
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME CLASS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Game {
    static canvas = document.getElementById('gameCanvas');
    static ctx = Game.canvas ? Game.canvas.getContext('2d') : null;
    static scale = 1;
    static groundHeight = CONFIG.GROUND_HEIGHT;

    static init() {
        console.log('Game.init: Iniciando');
        
        if (!Game.canvas) Game.canvas = document.getElementById('gameCanvas');
        if (!Game.ctx && Game.canvas) Game.ctx = Game.canvas.getContext('2d');

        if (!Game.canvas || !Game.ctx) {
            console.error('Canvas nÃ£o encontrado!');
            return;
        }

        Game.resize();

        gameState = new GameState();
        player = new Player();
        obstacleManager = new ObstacleManager();
        outdoorManager = new OutdoorManager();
        powerUpManager = new PowerUpManager();
        ParticleSystem.instance = new ParticleSystem();

        Renderer.instance = new Renderer(Game.canvas, Game.ctx);
        
        const bgImages = Images.bgSequence && Images.bgSequence.length ? Images.bgSequence : [];
        Renderer.instance.backgroundManager = new BackgroundManager(Game.canvas, bgImages);

        Game.setupEventListeners();
        Game.draw();
        
        console.log('Game.init: ConcluÃ­do');
    }

    static resize() {
        if (!Game.canvas) return;

        // Resize canvas to fit the #game-wrapper container instead of the full window
        const wrapper = document.getElementById('game-wrapper');
        const wrapperRect = wrapper ? wrapper.getBoundingClientRect() : null;

        const viewportWidth = wrapperRect ? Math.max(300, Math.floor(wrapperRect.width)) : window.innerWidth;
        const viewportHeight = wrapperRect ? Math.max(200, Math.floor(wrapperRect.height)) : window.innerHeight;

        Game.canvas.width = viewportWidth;
        Game.canvas.height = viewportHeight;

        const isPortrait = viewportHeight > viewportWidth;
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || viewportWidth <= 768;

        if (isPortrait) {
            Game.scale = Math.min(viewportWidth / 650, viewportHeight / 850);
        } else {
            Game.scale = Math.min(viewportWidth / 800, viewportHeight / 500);
        }

        Game.scale = Math.max(0.5, Math.min(Game.scale, 2.5));

        if (isMobile) {
            Game.groundHeight = Math.max(80, viewportHeight * 0.08) * Game.scale;
        } else {
            Game.groundHeight = Math.max(40, viewportHeight * 0.08) * Game.scale;
        }

        if (player) {
            const playerBaseSize = 60 * Game.scale;
            player.w = playerBaseSize;
            player.h = playerBaseSize;
            player.originalH = playerBaseSize;
            player.x = Game.canvas.width * 0.1;
            player.groundY = Game.canvas.height - Game.groundHeight - (5 * Game.scale);

            if (!gameState?.isRunning) {
                player.y = player.groundY - player.h;
                player.dy = 0;
            }
        }

        if (Renderer.instance?.backgroundManager) {
            Renderer.instance.backgroundManager.resize();
        }
    }

    static setupEventListeners() {
        let resizeTimeout;
        const handleResize = () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                Game.resize();
                if (!gameState.isRunning) Game.draw();
            }, 100);
        };
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', handleResize);

        document.addEventListener('keydown', (e) => {
            if (!gameState.isRunning) return;

            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                e.preventDefault();
                player.jump();
            }

            if (e.code === 'KeyS' || e.code === 'ArrowDown') {
                e.preventDefault();
                player.startCrouch();
            }

            if (e.code === 'KeyD') {
                CONFIG.DEBUG_MODE = !CONFIG.DEBUG_MODE;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyS' || e.code === 'ArrowDown') {
                player.stopCrouch();
            }
        });

        let touchStartY = 0;
        const swipeThreshold = 50;
        let hasJumped = false;

        Game.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isRunning) return;

            touchStartY = e.touches[0].clientY;
            hasJumped = false;
        }, { passive: false });

        Game.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!gameState.isRunning) return;

            const touchEndY = e.touches[0].clientY;
            const diffY = touchStartY - touchEndY;

            if (diffY < -swipeThreshold) {
                if (!player.isCrouching) {
                    player.startCrouch();
                }
            } 
            else if (diffY > swipeThreshold) {
                if (!hasJumped) {
                    player.jump();
                    hasJumped = true;
                }
            }
        }, { passive: false });

        Game.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            player.stopCrouch();
        });

        Game.canvas.addEventListener('mousedown', (e) => {
            if (!gameState.isRunning) return;
            const wrapper = document.getElementById('game-wrapper');
            const rect = wrapper ? wrapper.getBoundingClientRect() : { left: 0, width: window.innerWidth };
            const mouseX = e.clientX - rect.left;
            const screenMiddle = rect.width / 2;
            mouseX < screenMiddle ? player.startCrouch() : player.jump();
        });

        Game.canvas.addEventListener('mouseup', () => {
            player.stopCrouch();
        });

        document.querySelectorAll('.pixel-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.pixel-btn').forEach(b => {
                    b.classList.remove('active');
                });
                e.target.classList.add('active');
                currentDifficulty = e.target.dataset.difficulty;
            });
        });

        const startBtn = document.getElementById('start-button');
        if (startBtn) {
            startBtn.addEventListener('click', () => Game.start());
        }
        
        const restartBtn = document.getElementById('restart-button');
        if (restartBtn) {
            restartBtn.addEventListener('click', () => Game.start());
        }
    }

    static start() {
        gameState.reset();
        gameState.isRunning = true;
        gameState.currentSpeed = CONFIG.BASE_SPEED * Game.scale;
        gameState.frameCount = 0;
        obstacleManager.clear();
        outdoorManager.clear();
        powerUpManager.clear();
        ParticleSystem.instance.clear();

        player.y = player.groundY - player.h;
        player.dy = 0;
        player.jumpCount = 0;
        player.maxJumps = 2;
        player.isCrouching = false;
        player.isFastFalling = false;

        Game.updateUI();
        Game.loop();
    }

    static update() {
        gameState.score = Math.floor(gameState.frameCount / CONFIG.SCORE_DIVISOR);

        if (gameState.slowMotionActive && gameState.frameCount >= gameState.slowMotionEndFrame) {
            gameState.slowMotionActive = false;
        }
        const slowMotionFactor = gameState.slowMotionActive ? 0.5 : 1.0;

        const safeScale = Math.max(0.5, Math.min(Game.scale || 1, 2.5));

        const difficultyMod = DIFFICULTIES[currentDifficulty].speedMultiplier;
        const speedMultiplier = (1 + (gameState.score * CONFIG.SPEED_ACCELERATION)) * difficultyMod;
        gameState.currentSpeed = CONFIG.BASE_SPEED * speedMultiplier * safeScale * slowMotionFactor;

        const maxSpeed = CONFIG.BASE_SPEED * CONFIG.MAX_SPEED_MULTIPLIER * safeScale * slowMotionFactor;
        gameState.currentSpeed = Math.min(gameState.currentSpeed, maxSpeed);

        gameState.gridOffset += gameState.currentSpeed;

        player.update();
        obstacleManager.update(gameState.currentSpeed);
        outdoorManager.update(gameState.currentSpeed);
        powerUpManager.update(gameState.currentSpeed);
        ParticleSystem.instance.update(gameState.currentSpeed);

        if (!gameState.activePowerUpCimed && obstacleManager.checkCollision(player.hitbox)) {
            Game.gameOver();
        }

        const collectedPowerUp = powerUpManager.checkCollision(player.hitbox);
        if (collectedPowerUp) {
            const duration = powerUpsAssets[collectedPowerUp].effectDuration;
            const durationFrames = Math.floor(duration / (1000 / 60));
            gameState.slowMotionActive = true;
            gameState.slowMotionEndFrame = gameState.frameCount + durationFrames;
            gameState.activePowerUpCimed = collectedPowerUp;
            gameState.powerUpStartY = player.y;
            gameState.powerUpStartFrame = gameState.frameCount;

            const extraDelayFrames = 60;
            gameState.obstacleSpawnBlockedUntilFrame = gameState.slowMotionEndFrame + extraDelayFrames;

            ParticleSystem.create(player.x + player.w / 1, player.y + player.h / 2, 10, '#FFD700');
        }
        if (gameState.activePowerUpCimed && gameState.frameCount >= gameState.slowMotionEndFrame) {
            gameState.activePowerUpCimed = null;
            gameState.obstacleSpawnBlockedUntilFrame = Math.max(gameState.obstacleSpawnBlockedUntilFrame || 0, gameState.frameCount + 60);
        }

        gameState.frameCount++;
    }

    static draw() {
        if (!Renderer.instance) return;

        Renderer.instance.clear();
        Renderer.instance.drawBackground();

        if (outdoorManager) {
            outdoorManager.draw(Game.ctx);
        }

        Renderer.instance.drawGround();

        if (ParticleSystem.instance) {
            ParticleSystem.instance.draw(Game.ctx);
        }
        
        if (powerUpManager) {
            powerUpManager.draw(Game.ctx);
        }
        
        if (player) {
            player.draw(Game.ctx);
        }
        
        if (obstacleManager) {
            obstacleManager.draw(Game.ctx);
        }
        
        if (player && obstacleManager) {
            Renderer.instance.drawDebug(player, obstacleManager.obstacles);
        }

        if (gameState) {
            const scoreDisplay = document.getElementById('score-display');
            if (scoreDisplay) {
                scoreDisplay.innerText = gameState.score;
            }
        }
    }

    static loop() {
        if (!gameState.isRunning) return;

        Game.update();
        Game.draw();
        requestAnimationFrame(Game.loop);
    }

    static gameOver() {
        gameState.isRunning = false;
        gameState.isGameOver = true;
        Game.updateUI();
        Game.draw();
    }

    static updateUI() {
        const finalScore = document.getElementById('final-score-val');
        if (finalScore) {
            finalScore.innerText = gameState.score;
        }

        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');

        if (startScreen && gameOverScreen) {
            if (gameState.isRunning) {
                startScreen.classList.add('hidden');
                gameOverScreen.classList.add('hidden');
            } else if (gameState.isGameOver) {
                startScreen.classList.add('hidden');
                gameOverScreen.classList.remove('hidden');
            } else {
                startScreen.classList.remove('hidden');
                gameOverScreen.classList.add('hidden');
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INICIALIZAÃ‡ÃƒO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let gameState = null;
let player = null;
let obstacleManager = null;
let outdoorManager = null;
let powerUpManager = null;

class LoadingManager {
    constructor() {
        this.loadingScreen = document.getElementById('loading-screen');
        this.progressBar = document.getElementById('loading-progress');
        this.loadingText = document.getElementById('loading-text');
        this.loadingDetails = document.getElementById('loading-details');
        
        this.totalAssets = 0;
        this.loadedAssets = 0;
    }
    
    updateProgress(loaded, total, message = '') {
        this.loadedAssets = loaded;
        this.totalAssets = total;
        
        const percentage = Math.floor((loaded / total) * 100);
        
        if (this.progressBar) {
            this.progressBar.style.width = percentage + '%';
        }
        
        if (this.loadingText) {
            this.loadingText.textContent = `Carregando... ${percentage}%`;
        }
        
        if (this.loadingDetails && message) {
            this.loadingDetails.textContent = message;
        }
    }
    
    setMessage(message) {
        if (this.loadingDetails) {
            this.loadingDetails.textContent = message;
        }
    }
    
    hide() {
        if (this.loadingScreen) {
            this.loadingScreen.classList.add('hidden');
            setTimeout(() => {
                this.loadingScreen.style.display = 'none';
            }, 500);
        }
    }
}

const loadingManager = new LoadingManager();

const assetMessages = {
    'raposinho': 'Preparando o Raposinho...',
    'jump': 'Treinando os pulos...',
    'crouch': 'Aprendendo a se abaixar...',
    'fastfall': 'Praticando mergulhos...',
    'fall': 'Testando a gravidade...',
    'bola': 'Enchendo as bolas...',
    'chute': 'Dobrando as camisas...',
    'outdoor': 'Instalando os outdoors...'
};

function getFriendlyMessage(assetName) {
    for (let key in assetMessages) {
        if (assetName.includes(key)) {
            return assetMessages[key];
        }
    }
    return `Carregando ${assetName}...`;
}

async function simulateLoadingSteps() {
    const steps = [
        { progress: 10, message: 'Iniciando sistemas...', delay: 300 },
        { progress: 40, message: 'Preparando o campo...', delay: 300 },
        { progress: 70, message: 'Calibrando fÃ­sica...', delay: 300 },
        { progress: 85, message: 'Finalizando...', delay: 300 }
    ];
    
    for (let step of steps) {
        loadingManager.updateProgress(step.progress, 100, step.message);
        await new Promise(resolve => setTimeout(resolve, step.delay));
    }
}

function loadAllAssets() {
    return new Promise((resolve) => {
        const imagesToLoad = [];
        
        Object.keys(Images).forEach(key => {
            if (key === 'bgSequence') {
                Images.bgSequence.forEach((img, index) => imagesToLoad.push({
                    img, 
                    name: 'Background' + index,
                    displayName: `CenÃ¡rio ${index + 1}`
                }));
            } else {
                imagesToLoad.push({
                    img: Images[key], 
                    name: key,
                    displayName: key
                });
            }
        });
        
        const totalImages = imagesToLoad.length;
        let loadedImages = 0;
        
        loadingManager.updateProgress(0, totalImages, 'Preparando...');
        
        const checkComplete = () => {
            if (loadedImages >= totalImages) {
                resolve();
            }
        };
        
        imagesToLoad.forEach(({img, name}) => {
            if (img.complete && img.naturalWidth > 0) {
                loadedImages++;
                const friendlyMsg = getFriendlyMessage(name);
                loadingManager.updateProgress(loadedImages, totalImages, friendlyMsg);
                checkComplete();
            } else {
                img.onload = () => {
                    loadedImages++;
                    const friendlyMsg = getFriendlyMessage(name);
                    loadingManager.updateProgress(loadedImages, totalImages, friendlyMsg);
                    checkComplete();
                };
                
                img.onerror = () => {
                    loadedImages++;
                    loadingManager.updateProgress(loadedImages, totalImages, `Erro: ${name}`);
                    checkComplete();
                };
                
                if (!img.src) {
                    loadedImages++;
                    checkComplete();
                }
            }
        });
        
        setTimeout(() => {
            if (loadedImages < totalImages) {
                resolve();
            }
        }, 10000);
    });
}

async function initGame() {
    if (gameState) {
        return;
    }
    
    try {
        loadingManager.setMessage('Bem-vindo!');
        await new Promise(resolve => setTimeout(resolve, 500));
        
        await loadAllAssets();
        await simulateLoadingSteps();
        
        loadingManager.updateProgress(95, 100, 'Preparando controles...');
        await new Promise(resolve => setTimeout(resolve, 300));
        
        loadingManager.updateProgress(100, 100, 'Pronto!');
        await new Promise(resolve => setTimeout(resolve, 500));
        
        Game.init();
        
        await new Promise(resolve => setTimeout(resolve, 500));
        loadingManager.hide();
        
    } catch (error) {
        console.error('Erro ao inicializar:', error);
        if (loadingManager.loadingDetails) {
            loadingManager.loadingDetails.textContent = 'Erro! Recarregue a pÃ¡gina.';
            loadingManager.loadingDetails.style.color = '#ff4444';
        }
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGame);
} else {
    initGame();
}
</script>
</section>
    </section>

    <section class="historico">
        <div class="historico-jogo">
            <div class="foto-historica">
                <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/5d88fef8-24f1-45c9-bb94-456afdfbb83f.png" alt="Cruzeiro 1x0 AmÃ©rica - jogo histÃ³rico" loading="lazy">
            </div>
            <div class="detalhes-jogo">
                <div class="titulo-historico">
                    <span class="titulo">JOGO HISTÃ“RICO</span>
                    <span class="data">21/07/1996</span>
             <span style="font-size: 0.9rem; color: var(--cor-texto-secundario); margin-bottom: 0.5rem; display: block;">MINEIRÃƒO</span>
                    <div class="placar">
                        <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/ba47dc72-d3e9-4d87-bc2a-8503b208602a.png" class="escudo-mini" alt="Cruzeiro">
                        <span class="gols">1&nbsp;</span>
                      <div class="divisoria"></div>
                        <span class="gols">0&nbsp;</span>
                        <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/79f5dc99-e095-4f58-885a-c64bd96fe4af.png" class="escudo-mini" alt="AmÃ©rica-MG">
                    </div>
                </div>
            </div>

        </div>
    </section>

    <section class="escalacoes">
        <div class="time">
            <strong>CRUZEIRO</strong>
            <ul>
              <li>William Andem</li>
				<li>VÃ­tor</li>
				<li>CÃ©lio LÃºcio</li>
				<li>Gilmar</li>
                <li>Nonato</li>
                <li>Ricardinho</li>
                <li>Donizete Oliveira</li>
                <li>Palhinha (LuÃ­s Fernando Flores)</li>
                <li>Cleison (Marcos Teixeira)</li>
                <li>Marcelo Ramos (Edmundo)</li>
                <li>AÃ­lton âš½</li>

          </ul>
            <span class="tecnico">Tec. Levir Culpi</span>
        </div>
        <div class="time">
            <strong>AMÃ‰RICA-MG&nbsp;</strong>
            <ul>
              <li>Milagres</li>
                <li>Estevam</li>
                <li>Marins</li>
                <li>Ricardo</li>
    			<li>Wellington Paulo (Baiano)</li>
                <li>TaÃº</li>
                <li>EvanÃ­lson</li>
                <li>Renato (FlÃ¡vio)</li>
    			<li>ClÃ¡udio (Guiba)</li>
                <li>Alex Mineiro</li>
                <li>Celso</li>

            </ul>
            <span class="tecnico">Tec. Ricardo Drubscky</span>
        </div>
    </section>

    <section class="curiosidades">
        <h2 class="secao-titulo">ğŸ” CURIOSIDADE</h2>
        <p>
            <strong>TÃTULO SEM GOLS</strong><br><br>
      Ao bater o AmÃ©rica-MG na decisÃ£o da Copa dos CampeÃµes Mineiros de 1991, o Cruzeiro se tornou vencedor do torneio sem marcar um gol sequer. O campeonato, que seria realizado no estÃ¡dio IndependÃªncia durante um final de semana, teve em um lado da semifinal um confronto entre Cruzeiro e Villa Nova, enquanto na outra semifinal, o AmÃ©rica-MG enfrentava o AtlÃ©tico-MG. No sÃ¡bado, um empate por 0 a 0 e o Cruzeiro teve que superar o Villa Nova na decisÃ£o por pÃªnaltis (4 a 3). No domingo, na decisÃ£o do torneio, o Cruzeiro soube segurar o Ã­mpeto do AmÃ©rica-MG e, novamente, a partida terminou em 0 a 0. Nos pÃªnaltis, o Cruzeiro foi superior, venceu o AmÃ©rica-MG por 7 a 6 e se tornou o primeiro vencedor da Copa dos CampeÃµes Mineiros.
</p>
    </section>



    <section class="galery-player">
      <h2 class="secao-titulo" style="border-radius: 10px;">ARTILHARIA</h2>
        <div class="players-grid" id="players-start">
            <div class="port-player">
                <div class="position-player">Atacante</div>
                <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/9e8ecc27-d3e0-4e6f-a860-16edf213a938.png" alt="Niginho" class="player-image">
                <h3 class="player-name">NIGINHO</h3>
                <div class="player-number">48 GOLS&nbsp;</div>
            </div>
            <div class="port-player">
                <div class="position-player">Atacante</div>
                <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/9ae5f850-7e3d-496d-9bd8-8d7e0744786e.png" alt="Alcides" class="player-image">
                <h3 class="player-name">ALCIDES</h3>
                <div class="player-number">32 GOLS</div>
            </div>
            <div class="port-player">
                <div class="position-player">Atacante</div>
                <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/e7fd9c04-b05a-4f90-b916-04d292b35098.png" alt="NinÃ£o" class="player-image">
                <h3 class="player-name">NINÃƒO</h3>
                <div class="player-number">27 GOLS</div>
            </div>
            <div class="port-player">
                <div class="position-player">Atacante</div>
                <img src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/efdad800-3669-4c8c-9efa-aac03e20d80f.png" alt="Bengala" class="player-image">
                <h3 class="player-name">BENGALA</h3>
                <div class="player-number">25 GOLS</div>
            </div>

        </div>
        <div id="players-end"></div>
    </section>



    <footer class="rodape">
        <img id="footer-logo" alt="Logo Cruzeiro" src="https://image.crm.cruzeiro.com.br/lib/fe34117371640478741c71/m/1/1a619f2e-4cbe-4a07-a2d7-d32c26a5ea6d.png" width="50" height="auto">
    </footer>
<script>
    // Use o formato ISO: "Ano-MÃªs-DiaTHora:Minuto:Segundo"
    // Fevereiro Ã© 02. No formato String ISO, os meses sÃ£o de 01 a 12.
    const targetDate = new Date("2026-02-08T18:00:00").getTime();

    const countdown = setInterval(() => {
        const now = new Date().getTime();
        const distance = targetDate - now;

        // Se o elemento nÃ£o existir na DOM ainda, evita erro no console
        const timerElement = document.getElementById("timer");
        if (!timerElement) return;

        if (distance < 0) {
            clearInterval(countdown);
            timerElement.innerHTML = "Tempo esgotado!";
            return;
        }

        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);

        timerElement.innerHTML = `${days}D ${hours}H ${minutes}M ${seconds}S`;
    }, 1000);
</script>


</body></html>